/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.featurevisor.sdk

import com.featurevisor.sdk.FeaturevisorError.MissingDatafileOptions
import com.featurevisor.types.*
import com.featurevisor.types.EventName.*
import io.ktor.utils.io.charsets.Charsets
import io.ktor.utils.io.core.String
import io.ktor.utils.io.core.toByteArray
import kotlinx.coroutines.Job
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.IO
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import kotlinx.serialization.json.Json
import kotlin.native.concurrent.ThreadLocal

typealias ConfigureBucketKey = (Feature, Context, BucketKey) -> BucketKey
typealias ConfigureBucketValue = (Feature, Context, BucketValue) -> BucketValue
typealias InterceptContext = (Context) -> Context
typealias DatafileFetchHandler = (datafileUrl: String) -> Result<DatafileContent>

var emptyDatafile = DatafileContent(
    schemaVersion =  "1",
    revision = "unknown",
    attributes = emptyList(),
    segments = emptyList(),
    features = emptyList(),
)

class FeaturevisorInstance private constructor(options: InstanceOptions) {

    companion object {
        fun createInstance(options: InstanceOptions): FeaturevisorInstance {
            return FeaturevisorInstance(options)
        }

        var companionLogger: Logger? = null
    }

    private val on: (EventName, Listener) -> Unit
    private val off: (EventName) -> Unit
    private val addListener: (EventName, Listener) -> Unit
    private val removeListener: (EventName) -> Unit
    private val removeAllListeners: () -> Unit

    internal val fetchCoroutineScope = options.coroutineScope ?: CoroutineScope(SupervisorJob() + Dispatchers.IO)

    internal val statuses = Statuses(ready = false, refreshInProgress = false)

    internal val logger = options.logger
    internal val initialFeatures = options.initialFeatures
    internal val interceptContext = options.interceptContext
    internal val emitter: Emitter = Emitter()
    internal val datafileUrl = options.datafileUrl
    internal val handleDatafileFetch = options.handleDatafileFetch
    internal val refreshInterval = options.refreshInterval

    internal var datafileReader: DatafileReader

    internal var stickyFeatures = options.stickyFeatures
    internal var bucketKeySeparator = options.bucketKeySeparator
    internal var configureBucketKey = options.configureBucketKey
    internal var configureBucketValue = options.configureBucketValue
    internal var refreshJob: Job? = null

    init {
        // Create a debug logging function that always outputs
        fun debugLog(message: String, data: Map<String, Any>? = null) {
            // Always print to console for debugging
            println("üîß Featurevisor: $message")

            // Also try the logger if available
            try {
                logger?.debug(message, data ?: emptyMap())
            } catch (e: Exception) {
                println("üîß Logger failed: ${e.message}")
            }
        }

        fun errorLog(message: String, error: Throwable? = null, data: Map<String, Any>? = null) {
            // Always print to console for debugging
            println("üö® Featurevisor ERROR: $message ${error?.message ?: ""}")
            error?.printStackTrace()

            // Also try the logger if available
            try {
                logger?.error(message, (data ?: emptyMap()) + if (error != null) mapOf("error" to error) else emptyMap())
            } catch (e: Exception) {
                println("üö® Logger failed: ${e.message}")
            }
        }

        debugLog("üèóÔ∏è FeaturevisorInstance init started")

        with(options) {
            try {
                debugLog("üèóÔ∏è Setting up companion logger")
                companionLogger = logger

                debugLog("üèóÔ∏è Setting up event listeners...")
                if (onReady != null) {
                    debugLog("   - Adding READY listener")
                    emitter.addListener(event = READY, listener = onReady)
                }

                if (onRefresh != null) {
                    debugLog("   - Adding REFRESH listener")
                    emitter.addListener(REFRESH, onRefresh)
                }
                if (onUpdate != null) {
                    debugLog("   - Adding UPDATE listener")
                    emitter.addListener(UPDATE, onUpdate)
                }
                if (onActivation != null) {
                    debugLog("   - Adding ACTIVATION listener")
                    emitter.addListener(ACTIVATION, onActivation)
                }
                if (onError != null) {
                    debugLog("   - Adding ERROR listener")
                    emitter.addListener(ERROR, onError)
                }

                debugLog("üèóÔ∏è Setting up emitter functions")
                on = emitter::addListener
                off = emitter::removeListener
                addListener = emitter::addListener
                removeListener = emitter::removeListener
                removeAllListeners = emitter::removeAllListeners

                debugLog("üèóÔ∏è Checking initialization options", mapOf(
                    "hasDatafile" to (datafile != null),
                    "datafileUrl" to (datafileUrl ?: "NULL"),
                    "hasCustomScope" to (options.coroutineScope != null)
                ))

                when {
                    datafile != null -> {
                        debugLog("üèóÔ∏è Using provided datafile")
                        datafileReader = DatafileReader(datafile)
                        statuses.ready = true
                        emitter.emit(READY, datafile)
                        debugLog("‚úÖ FeaturevisorInstance static datafile initialization completed")
                    }

                    datafileUrl != null -> {
                        debugLog("üèóÔ∏è Using datafile URL", mapOf("url" to datafileUrl))
                        debugLog("üèóÔ∏è Creating empty DatafileReader...")

                        try {
                            datafileReader = DatafileReader(options.datafile ?: emptyDatafile)
                            debugLog("‚úÖ DatafileReader created successfully")
                        } catch (e: Exception) {
                            errorLog("‚ùå DatafileReader creation failed", e)
                            throw e
                        }

                        debugLog("üèóÔ∏è Launching coroutine for datafile fetch...")

                        try {
                            fetchCoroutineScope.launch {
                                debugLog("üöÄ Starting datafile fetch in coroutine...")

                                try {
                                    debugLog("üîç About to call fetchDatafileContent...", mapOf(
                                        "url" to datafileUrl,
                                        "hasHandler" to (handleDatafileFetch != null)
                                    ))

                                    fetchDatafileContent(datafileUrl, handleDatafileFetch) { result ->
                                        debugLog("üìã Fetch callback received", mapOf("success" to result.isSuccess))

                                        if (result.isSuccess) {
                                            try {
                                                val datafileContent = result.getOrThrow()
                                                debugLog("‚úÖ Datafile received", mapOf(
                                                    "featuresCount" to datafileContent.features.size,
                                                    "revision" to datafileContent.revision
                                                ))

                                                datafileReader = DatafileReader(datafileContent)
                                                statuses.ready = true

                                                debugLog("üì§ Emitting READY event with datafile content")
                                                emitter.emit(READY, datafileContent)

                                                if (refreshInterval != null) {
                                                    debugLog("üîÑ Starting auto-refresh")
                                                    startRefreshing()
                                                }
                                            } catch (e: Exception) {
                                                errorLog("‚ùå Error processing successful fetch result", e)
                                                emitter.emit(ERROR, e)
                                            }
                                        } else {
                                            val exception = result.exceptionOrNull()
                                            errorLog("‚ùå Fetch failed", exception, mapOf(
                                                "exceptionType" to (exception ?: "Unknown")
                                            ))

                                            emitter.emit(ERROR, exception ?: Exception("Unknown fetch failure"))
                                        }
                                    }

                                    debugLog("‚úÖ fetchDatafileContent call completed")

                                } catch (e: Exception) {
                                    errorLog("‚ùå Exception in coroutine during fetch", e)
                                    emitter.emit(ERROR, e)
                                }
                            }

                            debugLog("‚úÖ Coroutine launched successfully")

                        } catch (e: Exception) {
                            errorLog("‚ùå Failed to launch coroutine", e)
                            emitter.emit(ERROR, e)
                        }
                    }

                    else -> {
                        errorLog("‚ùå No datafile or datafileUrl provided")
                        throw MissingDatafileOptions
                    }
                }

                debugLog("‚úÖ FeaturevisorInstance init completed successfully")

            } catch (e: Exception) {
                errorLog("‚ùå FeaturevisorInstance init failed", e)

                // Make sure to emit the error so the callback gets it
                try {
                    emitter.emit(ERROR, e)
                } catch (emitError: Exception) {
                    errorLog("‚ùå Failed to emit error", emitError)
                }

                throw e
            }
        }
    }

    fun setLogLevels(levels: List<Logger.LogLevel>) {
        this.logger?.setLevels(levels)
    }

    fun setDatafile(datafileJSON: String) {
        val data = datafileJSON.toByteArray(Charsets.UTF_8)
        try {
            val datafileContent = Json.decodeFromString<DatafileContent>(String(data))
            datafileReader = DatafileReader(datafileContent = datafileContent)
        } catch (e: Exception) {
            logger?.error("could not parse datafile", mapOf("error" to e))
        }
    }

    fun setDatafile(datafileContent: DatafileContent) {
        datafileReader = DatafileReader(datafileContent = datafileContent)
    }

    fun setStickyFeatures(stickyFeatures: StickyFeatures?) {
        this.stickyFeatures = stickyFeatures
    }

    fun getRevision(): String {
        return datafileReader.getRevision()
    }

    fun shutdown() {
        fetchCoroutineScope.cancel()
        refreshJob?.cancel()
    }
}