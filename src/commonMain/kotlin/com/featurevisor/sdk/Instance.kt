/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.featurevisor.sdk

import com.featurevisor.sdk.FeaturevisorError.MissingDatafileOptions
import com.featurevisor.types.*
import com.featurevisor.types.EventName.*
import io.ktor.utils.io.charsets.Charsets
import io.ktor.utils.io.core.String
import io.ktor.utils.io.core.toByteArray
import kotlinx.coroutines.Job
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.IO
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import kotlinx.serialization.json.Json

typealias ConfigureBucketKey = (Feature, Context, BucketKey) -> BucketKey
typealias ConfigureBucketValue = (Feature, Context, BucketValue) -> BucketValue
typealias InterceptContext = (Context) -> Context
typealias DatafileFetchHandler = (datafileUrl: String) -> Result<DatafileContent>

var emptyDatafile = DatafileContent(
    schemaVersion =  "1",
    revision = "unknown",
    attributes = emptyList(),
    segments = emptyList(),
    features = emptyList(),
)

class FeaturevisorInstance private constructor(options: InstanceOptions) {

    companion object {
        fun createInstance(options: InstanceOptions): FeaturevisorInstance {
            return FeaturevisorInstance(options)
        }

        var companionLogger: Logger? = null
    }

    private val on: (EventName, Listener) -> Unit
    private val off: (EventName) -> Unit
    private val addListener: (EventName, Listener) -> Unit
    private val removeListener: (EventName) -> Unit
    private val removeAllListeners: () -> Unit

    internal val fetchCoroutineScope = options.coroutineScope ?: CoroutineScope(SupervisorJob() + Dispatchers.IO)

    internal val statuses = Statuses(ready = false, refreshInProgress = false)

    internal val logger = options.logger
    internal val initialFeatures = options.initialFeatures
    internal val interceptContext = options.interceptContext
    internal val emitter: Emitter = Emitter()
    internal val datafileUrl = options.datafileUrl
    internal val handleDatafileFetch = options.handleDatafileFetch
    internal val refreshInterval = options.refreshInterval

    internal var datafileReader: DatafileReader

    internal var stickyFeatures = options.stickyFeatures
    internal var bucketKeySeparator = options.bucketKeySeparator
    internal var configureBucketKey = options.configureBucketKey
    internal var configureBucketValue = options.configureBucketValue
    internal var refreshJob: Job? = null

    init {
        with(options) {
            companionLogger = logger
            if (onReady != null) {
                emitter.addListener(event = READY, listener = onReady)
            }

            if (onRefresh != null) {
                emitter.addListener(REFRESH, onRefresh)
            }
            if (onUpdate != null) {
                emitter.addListener(UPDATE, onUpdate)
            }
            if (onActivation != null) {
                emitter.addListener(ACTIVATION, onActivation)
            }
            if (onError != null) {
                emitter.addListener(ERROR, onError)
            }

            on = emitter::addListener
            off = emitter::removeListener
            addListener = emitter::addListener
            removeListener = emitter::removeListener
            removeAllListeners = emitter::removeAllListeners

            when {
                datafile != null -> {
                    datafileReader = DatafileReader(datafile)
                    statuses.ready = true
                    emitter.emit(READY, datafile)
                    println("FeaturevisorInstance datafile != null")
                }

                datafileUrl != null -> {
                    println("FeaturevisorInstance datafileUrl != null before datafilereader")
                    datafileReader = DatafileReader(options.datafile ?: emptyDatafile)

                    // Launch coroutine for fetching datafile
                    fetchCoroutineScope.launch {
                        println("ðŸš€ Starting datafile fetch in coroutine...")

                        fetchDatafileContent(datafileUrl, handleDatafileFetch) { result ->
                            println("ðŸ“‹ Fetch callback received: success=${result.isSuccess}")

                            if (result.isSuccess) {
                                try {
                                    val datafileContent = result.getOrThrow()
                                    println("âœ… Datafile received: ${datafileContent.features.size} features, revision ${datafileContent.revision}")

                                    datafileReader = DatafileReader(datafileContent)
                                    statuses.ready = true

                                    println("ðŸ“¤ Emitting READY event with datafile content")
                                    emitter.emit(READY, datafileContent)

                                    if (refreshInterval != null) {
                                        println("ðŸ”„ Starting auto-refresh")
                                        startRefreshing()
                                    }
                                } catch (e: Exception) {
                                    println("âŒ Error processing successful fetch result: ${e.message}")
                                    e.printStackTrace()
                                    logger?.error("Error processing datafile: ${e.message}")
                                    emitter.emit(ERROR, e) // Pass the actual error!
                                }
                            } else {
                                val exception = result.exceptionOrNull()
                                println("âŒ Fetch failed: $exception - ${exception?.message}")

                                logger?.error("Failed to fetch datafile: $result")

                                // FIXED: Pass the actual exception to ERROR event
                                emitter.emit(ERROR, exception ?: Exception("Unknown fetch failure"))
                            }
                        }
                    }
                }

                else -> throw MissingDatafileOptions
            }
        }
    }

    fun setLogLevels(levels: List<Logger.LogLevel>) {
        this.logger?.setLevels(levels)
    }

    fun setDatafile(datafileJSON: String) {
        val data = datafileJSON.toByteArray(Charsets.UTF_8)
        try {
            val datafileContent = Json.decodeFromString<DatafileContent>(String(data))
            datafileReader = DatafileReader(datafileContent = datafileContent)
        } catch (e: Exception) {
            logger?.error("could not parse datafile", mapOf("error" to e))
        }
    }

    fun setDatafile(datafileContent: DatafileContent) {
        datafileReader = DatafileReader(datafileContent = datafileContent)
    }

    fun setStickyFeatures(stickyFeatures: StickyFeatures?) {
        this.stickyFeatures = stickyFeatures
    }

    fun getRevision(): String {
        return datafileReader.getRevision()
    }

    fun shutdown() {
        fetchCoroutineScope.cancel()
        refreshJob?.cancel()
    }
}